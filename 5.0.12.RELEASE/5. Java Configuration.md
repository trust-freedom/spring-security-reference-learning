https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#jc

## 5. Java Configuration

General support for [Java Configuration](https://docs.spring.io/spring/docs/3.1.x/spring-framework-reference/html/beans.html#beans-java) was added to Spring Framework in Spring 3.1. Since Spring Security 3.2 there has been Spring Security Java Configuration support which enables users to easily configure Spring Security without the use of any XML.

If you are familiar with the [Security Namespace Configuration](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#ns-config) then you should find quite a few similarities between it and the Security Java Configuration support.

|      | Spring Security provides [lots of sample applications](https://github.com/spring-projects/spring-security/tree/master/samples/javaconfig) which demonstrate the use of Spring Security Java Configuration. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

### 5.1. Hello Web Security Java Configuration

The first step is to create our Spring Security Java Configuration. ==The configuration creates a Servlet Filter known as the `springSecurityFilterChain` which is responsible for all the security== (protecting the application URLs, validating submitted username and passwords, redirecting to the log in form, etc) within your application. You can find the most basic example of a Spring Security Java Configuration below:

```java
import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.context.annotation.*;
import org.springframework.security.config.annotation.authentication.builders.*;
import org.springframework.security.config.annotation.web.configuration.*;

@EnableWebSecurity
public class WebSecurityConfig implements WebMvcConfigurer {

	@Bean
	public UserDetailsService userDetailsService() throws Exception {
		InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
		manager.createUser(User.withDefaultPasswordEncoder().username("user").password("password").roles("USER").build());
		return manager;
	}
}
```

There really isn’t much to this configuration, but it does a lot. You can find a summary of the features below:

> 使用`@EnableWebSecurity`一个注解，搞定了以下这些？？
>
> 也就是说下面的是没配置默认提供的功能？？

- Require authentication to every URL in your application
- Generate a login form for you
- Allow the user with the **Username** *user* and the **Password** *password* to authenticate with form based authentication
- Allow the user to logout
- [CSRF attack](https://en.wikipedia.org/wiki/Cross-site_request_forgery) prevention
- [Session Fixation](https://en.wikipedia.org/wiki/Session_fixation) protection
- Security Header integration
  - [HTTP Strict Transport Security](https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security) for secure requests
  - [X-Content-Type-Options](https://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx) integration
  - Cache Control (can be overridden later by your application to allow caching of your static resources)
  - [X-XSS-Protection](https://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx) integration
  - X-Frame-Options integration to help prevent [Clickjacking](https://en.wikipedia.org/wiki/Clickjacking)
- Integrate with the following Servlet API methods（与以下Servlet API方法集成）
  - [HttpServletRequest#getRemoteUser()](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser())
  - [HttpServletRequest.html#getUserPrincipal()](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal())
  - [HttpServletRequest.html#isUserInRole(java.lang.String)](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String))
  - [HttpServletRequest.html#login(java.lang.String, java.lang.String)](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login(java.lang.String, java.lang.String))
  - [HttpServletRequest.html#logout()](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout())

#### 5.1.1. AbstractSecurityWebApplicationInitializer（springSecurityFilterChain如何初始化）

The next step is to register the `springSecurityFilterChain` with the war. This can be done in Java Configuration with [Spring’s WebApplicationInitializer support](https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-container-config) in a Servlet 3.0+ environment. Not suprisingly, Spring Security provides a base class `AbstractSecurityWebApplicationInitializer` that will ensure the `springSecurityFilterChain` gets registered for you. The way in which we use `AbstractSecurityWebApplicationInitializer` differs depending on if we are already using Spring or if Spring Security is the only Spring component in our application.

> `AbstractSecurityWebApplicationInitializer`是负责注册`springSecurityFilterChain`过滤器链的，其实现机制是使用SpringWeb的`WebApplicationInitializer`，可能类似于在Servlet容器启动后可以初始化执行的初始化器

- [AbstractSecurityWebApplicationInitializer without Existing Spring](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#abstractsecuritywebapplicationinitializer-without-existing-spring) - Use these instructions if you are not using Spring already
- [AbstractSecurityWebApplicationInitializer with Spring MVC](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#abstractsecuritywebapplicationinitializer-with-spring-mvc) - Use these instructions if you are already using Spring

#### 5.1.2. AbstractSecurityWebApplicationInitializer without Existing Spring

If you are not using Spring or Spring MVC, you will need to pass in the `WebSecurityConfig` into the superclass to ensure the configuration is picked up. You can find an example below:

```java
import org.springframework.security.web.context.*;

public class SecurityWebApplicationInitializer
	extends AbstractSecurityWebApplicationInitializer {

	public SecurityWebApplicationInitializer() {
		super(WebSecurityConfig.class);
	}
}
```

The `SecurityWebApplicationInitializer` will do the following things:

- Automatically register the springSecurityFilterChain Filter for every URL in your application
- Add a ContextLoaderListener that loads the [WebSecurityConfig](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#jc-hello-wsca).

#### 5.1.3. AbstractSecurityWebApplicationInitializer with Spring MVC

If we were using Spring elsewhere in our application we probably already had a `WebApplicationInitializer` that is loading our Spring Configuration. If we use the previous configuration we would get an error. Instead, we should register Spring Security with the existing `ApplicationContext`. For example, if we were using Spring MVC our `SecurityWebApplicationInitializer` would look something like the following:

```java
import org.springframework.security.web.context.*;

public class SecurityWebApplicationInitializer
	extends AbstractSecurityWebApplicationInitializer {

}
```

This would simply only register the springSecurityFilterChain Filter for every URL in your application. After that we would ensure that `WebSecurityConfig` was loaded in our existing ApplicationInitializer. For example, if we were using Spring MVC it would be added in the `getRootConfigClasses()`

```java
public class MvcWebApplicationInitializer extends
		AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class<?>[] getRootConfigClasses() {
		return new Class[] { WebSecurityConfig.class };
	}

	// ... other overrides ...
}
```

### 5.2. HttpSecurity

Thus far our [WebSecurityConfig](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#jc-hello-wsca) only contains information about how to authenticate our users. How does Spring Security know that we want to require all users to be authenticated? How does Spring Security know we want to support form based authentication? The reason for this is that the `WebSecurityConfigurerAdapter` provides a default configuration in the `configure(HttpSecurity http)` method that looks like:

> 上面配置的我们自己创建的WebSecurityConfig只是包含了如何认证用户，但Spring Security怎么知道我们需要认证所有用户？怎么知道我们需要based authentication？就要配置`HttpSecurity`

```java
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
			.anyRequest().authenticated()  //所有请求都需要被认证
			.and()
		.formLogin()  //允许用户使用表单认证
			.and()
		.httpBasic(); //允许用户使用HTTP Basic认证
}
```

The default configuration above:

- Ensures that any request to our application requires the user to be authenticated
- Allows users to authenticate with form based login
- Allows users to authenticate with HTTP Basic authentication

You will notice that this configuration is quite similar the XML Namespace configuration:

```xml
<http>
	<intercept-url pattern="/**" access="authenticated"/>
	<form-login />
	<http-basic />
</http>
```

The Java Configuration equivalent of closing an XML tag is expressed using the**<font color="red"> `and()` </font>**method which allows us to continue configuring the parent. If you read the code it also makes sense. I want to configure authorized requests *and* configure form login *and* configure HTTP Basic authentication.

However, Java Configuration has different defaults URLs and parameters. Keep this in mind when creating custom login pages. The result is that our URLs are more RESTful. Additionally, it is not quite so obvious we are using Spring Security which helps to prevent [information leaks](https://www.owasp.org/index.php/Information_Leak_(information_disclosure)). For example:

### 5.3. Java Configuration and Form Login（表单登录）

You might be wondering where the login form came from when you were prompted to log in, since we made no mention of any HTML files or JSPs. Since Spring Security’s default configuration does not explicitly set a URL for the login page, Spring Security generates one automatically, based on the features that are enabled and using standard values for the URL which processes the submitted login, the default target URL the user will be sent to after logging in and so on.

While the automatically generated log in page is convenient to get up and running quickly, most applications will want to provide their own log in page. To do so we can update our configuration as seen below:

> Spring Security提供了默认的登录页，如果想自定义登录页，按照如下：

![1565341834706](E:\MyCode\SpringSecurity\my-repositories\spring-security-reference-learning\5.0.12.RELEASE\5. Java Configuration.assets\1565341834706.png)

An example log in page implemented with JSPs for our current configuration can be seen below:

|      | The login page below represents our current configuration. We could easily update our configuration if some of the defaults do not meet our needs. |
| ---- | ------------------------------------------------------------ |
|      | 下面给出了一个JSP样例的自定义登录页，注意标数字的就是一些注意事项 |

![1565342169953](E:\MyCode\SpringSecurity\my-repositories\spring-security-reference-learning\5.0.12.RELEASE\5. Java Configuration.assets\1565342169953.png)

### 5.4. Authorize Requests（授权请求）

Our examples have only required users to be authenticated and have done so for every URL in our application. We can specify custom requirements for our URLs by adding multiple children to our `http.authorizeRequests()` method. For example:

![1565343944209](E:\MyCode\SpringSecurity\my-repositories\spring-security-reference-learning\5.0.12.RELEASE\5. Java Configuration.assets\1565343944209.png)

> 1、http.authorizeRequests())方法有多个子节点，==每个匹配器按其声明的顺序进行考虑==
>
> 2、我们指定了任何用户都可以访问的多种URL模式。具体来说，如果URL以“/resources/”开头，等于“/signup”或等于“/about”，任何用户都可以访问请求
>
> 3、任何以“/admin/”开头的URL都将仅限于具有“ROLE_ADMIN”角色的用户。您会注意到，由于我们正在调用hasRole方法，因此我们<font color="red">不需要指定“ROLE_”前缀</font>
>
> 4、任何以“/db/”开头的URL都要求用户同时拥有“ROLE_ADMIN”和“ROLE_DBA”。您会注意到，由于我们使用的是hasRole表达式，因此我们不需要指定“ROLE_”前缀
>
> 5、任何尚未匹配的URL只需要对用户进行身份验证（<font style="background-color:orange">自己：</font>所以应将anyRequest()放在最后）

### 5.5. Handling Logouts

When using the `WebSecurityConfigurerAdapter`, logout capabilities are automatically applied. The default is that accessing the URL `/logout` will log the user out by:

- Invalidating the HTTP Session
- Cleaning up any RememberMe authentication that was configured
- Clearing the `SecurityContextHolder`
- Redirect to `/login?logout`

Similar to configuring login capabilities, however, you also have various options to further customize your logout requirements:

```java
protected void configure(HttpSecurity http) throws Exception {
	http
		.logout()                                                                
			.logoutUrl("/my/logout")                                                 
			.logoutSuccessUrl("/my/index")                                           
			.logoutSuccessHandler(logoutSuccessHandler)                              
			.invalidateHttpSession(true)                                             
			.addLogoutHandler(logoutHandler)                                         
			.deleteCookies(cookieNamesToClear)                                       
			.and()
		...
}
```

|      | Provides logout support. This is automatically applied when using `WebSecurityConfigurerAdapter`. |
| ---- | ------------------------------------------------------------ |
|      | The URL that triggers log out to occur (default is `/logout`). If CSRF protection is enabled (default), then the request must also be a POST. For more information, please consult the [JavaDoc](https://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutUrl-java.lang.String-). |
|      | The URL to redirect to after logout has occurred. The default is `/login?logout`. For more information, please consult the [JavaDoc](https://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutSuccessUrl-java.lang.String-). |
|      | Let’s you specify a custom `LogoutSuccessHandler`. If this is specified, `logoutSuccessUrl()` is ignored. For more information, please consult the [JavaDoc](https://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutSuccessHandler-org.springframework.security.web.authentication.logout.LogoutSuccessHandler-). |
|      | Specify whether to invalidate the `HttpSession` at the time of logout. This is **true** by default. Configures the `SecurityContextLogoutHandler` under the covers. For more information, please consult the [JavaDoc](https://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#invalidateHttpSession-boolean-). |
|      | Adds a `LogoutHandler`. `SecurityContextLogoutHandler` is added as the last `LogoutHandler` by default. |
|      | Allows specifying the names of cookies to be removed on logout success. This is a shortcut for adding a `CookieClearingLogoutHandler` explicitly. |

|      | Logouts can of course also be configured using the XML Namespace notation. Please see the documentation for the [logout element](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#nsa-logout) in the Spring Security XML Namespace section for further details. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Generally, in order to customize logout functionality, you can add `LogoutHandler` and/or `LogoutSuccessHandler`implementations. For many common scenarios, these handlers are applied under the covers when using the fluent API.

#### 5.5.1. LogoutHandler

Generally, `LogoutHandler` implementations indicate classes that are able to participate in logout handling. They are expected to be invoked to perform necessary clean-up. As such they should not throw exceptions. Various implementations are provided:

- [PersistentTokenBasedRememberMeServices](https://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/rememberme/PersistentTokenBasedRememberMeServices.html)
- [TokenBasedRememberMeServices](https://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/rememberme/TokenBasedRememberMeServices.html)
- [CookieClearingLogoutHandler](https://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/logout/CookieClearingLogoutHandler.html)
- [CsrfLogoutHandler](https://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/csrf/CsrfLogoutHandler.html)
- [SecurityContextLogoutHandler](https://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html)

Please see [Remember-Me Interfaces and Implementations](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#remember-me-impls) for details.

Instead of providing `LogoutHandler` implementations directly, the fluent API also provides shortcuts that provide the respective `LogoutHandler` implementations under the covers. E.g. `deleteCookies()` allows specifying the names of one or more cookies to be removed on logout success. This is a shortcut compared to adding a`CookieClearingLogoutHandler`.

#### 5.5.2. LogoutSuccessHandler

The `LogoutSuccessHandler` is called after a successful logout by the `LogoutFilter`, to handle e.g. redirection or forwarding to the appropriate destination. Note that the interface is almost the same as the `LogoutHandler` but may raise an exception.

The following implementations are provided:

- [SimpleUrlLogoutSuccessHandler](https://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/logout/SimpleUrlLogoutSuccessHandler.html)
- HttpStatusReturningLogoutSuccessHandler

As mentioned above, you don’t need to specify the `SimpleUrlLogoutSuccessHandler` directly. Instead, the fluent API provides a shortcut by setting the `logoutSuccessUrl()`. This will setup the `SimpleUrlLogoutSuccessHandler` under the covers. The provided URL will be redirected to after a logout has occurred. The default is `/login?logout`.

The `HttpStatusReturningLogoutSuccessHandler` can be interesting in REST API type scenarios. Instead of redirecting to a URL upon the successful logout, this `LogoutSuccessHandler` allows you to provide a plain HTTP status code to be returned. If not configured a status code 200 will be returned by default.

#### 5.5.3. Further Logout-Related References

- [Logout Handling](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#ns-logout)
- [Testing Logout](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#test-logout)
- [HttpServletRequest.logout()](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#servletapi-logout)
- [Remember-Me Interfaces and Implementations](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#remember-me-impls)
- [Logging Out](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#csrf-logout) in section CSRF Caveats
- Section [Single Logout](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#cas-singlelogout) (CAS protocol)
- Documentation for the [logout element](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#nsa-logout) in the Spring Security XML Namespace section

### 5.6. WebFlux Security

Spring Security’s WebFlux support relies on a `WebFilter` and works the same for Spring WebFlux and Spring WebFlux.Fn. You can find a few sample applications that demonstrate the code below:

- Hello WebFlux [hellowebflux](https://github.com/spring-projects/spring-security/tree/5.0.12.RELEASE/samples/javaconfig/hellowebflux)
- Hello WebFlux.Fn [hellowebfluxfn](https://github.com/spring-projects/spring-security/tree/5.0.12.RELEASE/samples/javaconfig/hellowebfluxfn)
- Hello WebFlux Method [hellowebflux-method](https://github.com/spring-projects/spring-security/tree/5.0.12.RELEASE/samples/javaconfig/hellowebflux-method)

#### 5.6.1. Minimal WebFlux Security Configuration

You can find a minimal WebFlux Security configuration below:

```java
@EnableWebFluxSecurity
public class HelloWebfluxSecurityConfig {

	@Bean
	public MapReactiveUserDetailsService userDetailsService() {
		UserDetails user = User.withDefaultPasswordEncoder()
			.username("user")
			.password("user")
			.roles("USER")
			.build();
		return new MapReactiveUserDetailsService(user);
	}
}
```

This configuration provides form and http basic authentication, sets up authorization to require an authenticated user for accessing any page, sets up a default log in page and a default log out page, sets up security related HTTP headers, CSRF protection, and more.

#### 5.6.2. Explicit WebFlux Security Configuration

You can find an explicit version of the minimal WebFlux Security configuration below:

```java
@EnableWebFluxSecurity
public class HelloWebfluxSecurityConfig {

	@Bean
	public MapReactiveUserDetailsService userDetailsService() {
		UserDetails user = User.withDefaultPasswordEncoder()
			.username("user")
			.password("user")
			.roles("USER")
			.build();
		return new MapReactiveUserDetailsService(user);
	}

	@Bean
	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
		http
			.authorizeExchange()
				.anyExchange().authenticated()
				.and()
			.httpBasic().and()
			.formLogin();
		return http.build();
	}
}
```

This configuration explicitly sets up all the same things as our minimal configuration. From here you can easily make the changes to the defaults.

### 5.7. OAuth 2.0 Login

The OAuth 2.0 Login feature provides an application with the capability to have users log in to the application by using their existing account at an OAuth 2.0 Provider (e.g. GitHub) or OpenID Connect 1.0 Provider (such as Google). OAuth 2.0 Login implements the use cases: "Login with Google" or "Login with GitHub".

|      | OAuth 2.0 Login is implemented by using the **Authorization Code Grant**, as specified in the [OAuth 2.0 Authorization Framework](https://tools.ietf.org/html/rfc6749#section-4.1) and [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth). |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

#### 5.7.1. Spring Boot 2.0 Sample

Spring Boot 2.0 brings full auto-configuration capabilities for OAuth 2.0 Login.

This section shows how to configure the [**OAuth 2.0 Login sample**](https://github.com/spring-projects/spring-security/tree/5.0.12.RELEASE/samples/boot/oauth2login) using *Google* as the *Authentication Provider* and covers the following topics:

- [Initial setup](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#jc-oauth2login-sample-initial-setup)
- [Setting the redirect URI](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#jc-oauth2login-sample-redirect-uri)
- [Configure `application.yml`](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#jc-oauth2login-sample-application-config)
- [Boot up the application](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#jc-oauth2login-sample-boot-application)

##### Initial setup

To use Google’s OAuth 2.0 authentication system for login, you must set up a project in the Google API Console to obtain OAuth 2.0 credentials.

|      | [Google’s OAuth 2.0 implementation](https://developers.google.com/identity/protocols/OpenIDConnect) for authentication conforms to the [OpenID Connect 1.0](https://openid.net/connect/) specification and is [OpenID Certified](https://openid.net/certification/). |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Follow the instructions on the [OpenID Connect](https://developers.google.com/identity/protocols/OpenIDConnect) page, starting in the section, "Setting up OAuth 2.0".

After completing the "Obtain OAuth 2.0 credentials" instructions, you should have a new OAuth Client with credentials consisting of a Client ID and a Client Secret.

##### Setting the redirect URI

The redirect URI is the path in the application that the end-user’s user-agent is redirected back to after they have authenticated with Google and have granted access to the OAuth Client *(created in the previous step)* on the Consent page.

In the "Set a redirect URI" sub-section, ensure that the **Authorized redirect URIs** field is set to `http://localhost:8080/login/oauth2/code/google`.

|      | The default redirect URI template is `{baseUrl}/login/oauth2/code/{registrationId}`. The **registrationId** is a unique identifier for the [ClientRegistration](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#jc-oauth2login-client-registration). |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Configure `application.yml`

Now that you have a new OAuth Client with Google, you need to configure the application to use the OAuth Client for the *authentication flow*. To do so:

1. Go to `application.yml` and set the following configuration:

   ```yaml
   spring:
     security:
       oauth2:
         client:
           registration:	
             google:	
               client-id: google-client-id
               client-secret: google-client-secret
   ```

   Example 1. OAuth Client properties

   |      | `spring.security.oauth2.client.registration` is the base property prefix for OAuth Client properties. |
   | ---- | ------------------------------------------------------------ |
   |      | Following the base property prefix is the ID for the [ClientRegistration](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#jc-oauth2login-client-registration), such as google. |

2. Replace the values in the `client-id` and `client-secret` property with the OAuth 2.0 credentials you created earlier.

##### Boot up the application

Launch the Spring Boot 2.0 sample and go to `http://localhost:8080`. You are then redirected to the default *auto-generated* login page, which displays a link for Google.

Click on the Google link, and you are then redirected to Google for authentication.

After authenticating with your Google account credentials, the next page presented to you is the Consent screen. The Consent screen asks you to either allow or deny access to the OAuth Client you created earlier. Click **Allow** to authorize the OAuth Client to access your email address and basic profile information.

At this point, the OAuth Client retrieves your email address and basic profile information from the [UserInfo Endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo) and establishes an authenticated session.

#### 5.7.2. ClientRegistration

`ClientRegistration` is a representation of a client registered with an OAuth 2.0 or OpenID Connect 1.0 Provider.

A client registration holds information, such as client id, client secret, authorization grant type, redirect URI, scope(s), authorization URI, token URI, and other details.

`ClientRegistration` and its properties are defined as follows:

```java
public final class ClientRegistration {
	private String registrationId;	
	private String clientId;	
	private String clientSecret;	
	private ClientAuthenticationMethod clientAuthenticationMethod;	
	private AuthorizationGrantType authorizationGrantType;	
	private String redirectUriTemplate;	
	private Set<String> scopes;	
	private ProviderDetails providerDetails;
	private String clientName;	

	public class ProviderDetails {
		private String authorizationUri;	
		private String tokenUri;	
		private UserInfoEndpoint userInfoEndpoint;
		private String jwkSetUri;	

		public class UserInfoEndpoint {
			private String uri;	
			private String userNameAttributeName;	

		}
	}
}
```

|      | `registrationId`: The ID that uniquely identifies the `ClientRegistration`. |
| ---- | ------------------------------------------------------------ |
|      | `clientId`: The client identifier.                           |
|      | `clientSecret`: The client secret.                           |
|      | `clientAuthenticationMethod`: The method used to authenticate the Client with the Provider. The supported values are **basic** and **post**. |
|      | `authorizationGrantType`: The OAuth 2.0 Authorization Framework defines four [Authorization Grant](https://tools.ietf.org/html/rfc6749#section-1.3) types. The supported values are authorization_code and implicit. |
|      | `redirectUriTemplate`: The client’s registered redirect URI that the *Authorization Server* redirects the end-user’s user-agent to after the end-user has authenticated and authorized access to the client. The default redirect URI template is `{baseUrl}/login/oauth2/code/{registrationId}`, which supports URI template variables. |
|      | `scopes`: The scope(s) requested by the client during the Authorization Request flow, such as openid, email, or profile. |
|      | `clientName`: A descriptive name used for the client. The name may be used in certain scenarios, such as when displaying the name of the client in the auto-generated login page. |
|      | `authorizationUri`: The Authorization Endpoint URI for the Authorization Server. |
|      | `tokenUri`: The Token Endpoint URI for the Authorization Server. |
|      | `jwkSetUri`: The URI used to retrieve the [JSON Web Key (JWK)](https://tools.ietf.org/html/rfc7517) Set from the Authorization Server, which contains the cryptographic key(s) used to verify the [JSON Web Signature (JWS)](https://tools.ietf.org/html/rfc7515) of the ID Token and optionally the UserInfo Response. |
|      | `(userInfoEndpoint)uri`: The UserInfo Endpoint URI used to access the claims/attributes of the authenticated end-user. |
|      | `userNameAttributeName`: The name of the attribute returned in the UserInfo Response that references the Name or Identifier of the end-user. |

#### 5.7.3. Spring Boot 2.0 Property Mappings

The following table outlines the mapping of the Spring Boot 2.0 OAuth Client properties to the `ClientRegistration`properties.

| Spring Boot 2.0                                              | ClientRegistration                                       |
| :----------------------------------------------------------- | :------------------------------------------------------- |
| `spring.security.oauth2.client.registration.*[registrationId]*` | `registrationId`                                         |
| `spring.security.oauth2.client.registration.*[registrationId]*.client-id` | `clientId`                                               |
| `spring.security.oauth2.client.registration.*[registrationId]*.client-secret` | `clientSecret`                                           |
| `spring.security.oauth2.client.registration.*[registrationId]*.client-authentication-method` | `clientAuthenticationMethod`                             |
| `spring.security.oauth2.client.registration.*[registrationId]*.authorization-grant-type` | `authorizationGrantType`                                 |
| `spring.security.oauth2.client.registration.*[registrationId]*.redirect-uri-template` | `redirectUriTemplate`                                    |
| `spring.security.oauth2.client.registration.*[registrationId]*.scope` | `scopes`                                                 |
| `spring.security.oauth2.client.registration.*[registrationId]*.client-name` | `clientName`                                             |
| `spring.security.oauth2.client.provider.*[providerId]*.authorization-uri` | `providerDetails.authorizationUri`                       |
| `spring.security.oauth2.client.provider.*[providerId]*.token-uri` | `providerDetails.tokenUri`                               |
| `spring.security.oauth2.client.provider.*[providerId]*.jwk-set-uri` | `providerDetails.jwkSetUri`                              |
| `spring.security.oauth2.client.provider.*[providerId]*.user-info-uri` | `providerDetails.userInfoEndpoint.uri`                   |
| `spring.security.oauth2.client.provider.*[providerId]*.userNameAttribute` | `providerDetails.userInfoEndpoint.userNameAttributeName` |

#### 5.7.4. ClientRegistrationRepository

The `ClientRegistrationRepository` serves as a repository for OAuth 2.0 / OpenID Connect 1.0 `ClientRegistration`(s).

|      | Client registration information is ultimately stored and owned by the associated Authorization Server. This repository provides the ability to retrieve a sub-set of the primary client registration information, which is stored with the Authorization Server. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Spring Boot 2.0 auto-configuration binds each of the properties under `spring.security.oauth2.client.registration.*[registrationId]*` to an instance of `ClientRegistration` and then composes each of the `ClientRegistration` instance(s) within a `ClientRegistrationRepository`.

|      | The default implementation of `ClientRegistrationRepository` is `InMemoryClientRegistrationRepository`. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

The auto-configuration also registers the `ClientRegistrationRepository` as a `@Bean` in the `ApplicationContext`so that it is available for dependency-injection, if needed by the application.

The following listing shows an example:

```java
@Controller
public class MainController {

	@Autowired
	private ClientRegistrationRepository clientRegistrationRepository;

	@RequestMapping("/")
	public String index() {
		ClientRegistration googleRegistration =
			this.clientRegistrationRepository.findByRegistrationId("google");

		...

		return "index";
	}
}
```

#### 5.7.5. CommonOAuth2Provider

`CommonOAuth2Provider` pre-defines a set of default client properties for a number of well known providers: Google, GitHub, Facebook, and Okta.

For example, the `authorization-uri`, `token-uri`, and `user-info-uri` do not change often for a Provider. Therefore, it makes sense to provide default values in order to reduce the required configuration.

As demonstrated previously, when we [configured a Google client](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#jc-oauth2login-sample-application-config), only the `client-id` and `client-secret` properties are required.

The following listing shows an example:

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: google-client-id
            client-secret: google-client-secret
```

|      | The auto-defaulting of client properties works seamlessly here because the `registrationId` (`google`) matches the `GOOGLE` `enum` (case-insensitive) in `CommonOAuth2Provider`. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

For cases where you may want to specify a different `registrationId`, such as `google-login`, you can still leverage auto-defaulting of client properties by configuring the `provider` property.

The following listing shows an example:

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          google-login:	
            provider: google	
            client-id: google-client-id
            client-secret: google-client-secret
```

|      | The `registrationId` is set to `google-login`.               |
| ---- | ------------------------------------------------------------ |
|      | The `provider` property is set to `google`, which will leverage the auto-defaulting of client properties set in `CommonOAuth2Provider.GOOGLE.getBuilder()`. |

#### 5.7.6. Configuring Custom Provider Properties

There are some OAuth 2.0 Providers that support multi-tenancy, which results in different protocol endpoints for each tenant (or sub-domain).

For example, an OAuth Client registered with Okta is assigned to a specific sub-domain and have their own protocol endpoints.

For these cases, Spring Boot 2.0 provides the following base property for configuring custom provider properties: `spring.security.oauth2.client.provider.*[providerId]*`.

The following listing shows an example:

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
        provider:
          okta:	
            authorization-uri: https://your-subdomain.oktapreview.com/oauth2/v1/authorize
            token-uri: https://your-subdomain.oktapreview.com/oauth2/v1/token
            user-info-uri: https://your-subdomain.oktapreview.com/oauth2/v1/userinfo
            user-name-attribute: sub
            jwk-set-uri: https://your-subdomain.oktapreview.com/oauth2/v1/keys
```

|      | The base property (`spring.security.oauth2.client.provider.okta`) allows for custom configuration of protocol endpoint locations. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

#### 5.7.7. Overriding Spring Boot 2.0 Auto-configuration

The Spring Boot 2.0 Auto-configuration class for OAuth Client support is `OAuth2ClientAutoConfiguration`.

It performs the following tasks:

- Registers a `ClientRegistrationRepository` `@Bean` composed of `ClientRegistration`(s) from the configured OAuth Client properties.
- Provides a `WebSecurityConfigurerAdapter` `@Configuration` and enables OAuth 2.0 Login through `httpSecurity.oauth2Login()`.

If you need to override the auto-configuration based on your specific requirements, you may do so in the following ways:

- [Register a `ClientRegistrationRepository` `@Bean`](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#jc-oauth2login-register-clientregistrationrepository-bean)
- [Provide a `WebSecurityConfigurerAdapter`](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#jc-oauth2login-provide-websecurityconfigureradapter)
- [Completely Override the Auto-configuration](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#jc-oauth2login-completely-override-autoconfiguration)

##### Register a `ClientRegistrationRepository` `@Bean`

The following example shows how to register a `ClientRegistrationRepository` `@Bean`:

```java
@Configuration
public class OAuth2LoginConfig {

	@Bean
	public ClientRegistrationRepository clientRegistrationRepository() {
		return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
	}

	private ClientRegistration googleClientRegistration() {
		return ClientRegistration.withRegistrationId("google")
			.clientId("google-client-id")
			.clientSecret("google-client-secret")
			.clientAuthenticationMethod(ClientAuthenticationMethod.BASIC)
			.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
			.redirectUriTemplate("{baseUrl}/login/oauth2/code/{registrationId}")
			.scope("openid", "profile", "email", "address", "phone")
			.authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
			.tokenUri("https://www.googleapis.com/oauth2/v4/token")
			.userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
			.userNameAttributeName(IdTokenClaimNames.SUB)
			.jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
			.clientName("Google")
			.build();
	}
}
```

##### Provide a `WebSecurityConfigurerAdapter`

The following example shows how to provide a `WebSecurityConfigurerAdapter` with `@EnableWebSecurity` and enable OAuth 2.0 login through `httpSecurity.oauth2Login()`:

```java
@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests()
				.anyRequest().authenticated()
				.and()
			.oauth2Login();
	}
}
```

##### Completely Override the Auto-configuration

The following example shows how to completely override the auto-configuration by both registering a `ClientRegistrationRepository` `@Bean` and providing a `WebSecurityConfigurerAdapter`, both of which were described in the two preceding sections.

```java
@Configuration
public class OAuth2LoginConfig {

	@EnableWebSecurity
	public static class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			http
				.authorizeRequests()
					.anyRequest().authenticated()
					.and()
				.oauth2Login();
		}
	}

	@Bean
	public ClientRegistrationRepository clientRegistrationRepository() {
		return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
	}

	private ClientRegistration googleClientRegistration() {
		return ClientRegistration.withRegistrationId("google")
			.clientId("google-client-id")
			.clientSecret("google-client-secret")
			.clientAuthenticationMethod(ClientAuthenticationMethod.BASIC)
			.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
			.redirectUriTemplate("{baseUrl}/login/oauth2/code/{registrationId}")
			.scope("openid", "profile", "email", "address", "phone")
			.authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
			.tokenUri("https://www.googleapis.com/oauth2/v4/token")
			.userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
			.userNameAttributeName(IdTokenClaimNames.SUB)
			.jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
			.clientName("Google")
			.build();
	}
}
```

#### 5.7.8. Java Configuration without Spring Boot 2.0

If you are not able to use Spring Boot 2.0 and would like to configure one of the pre-defined providers in `CommonOAuth2Provider` (for example, Google), apply the following configuration:

```java
@Configuration
public class OAuth2LoginConfig {

	@EnableWebSecurity
	public static class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			http
				.authorizeRequests()
					.anyRequest().authenticated()
					.and()
				.oauth2Login();
		}
	}

	@Bean
	public ClientRegistrationRepository clientRegistrationRepository() {
		return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
	}

	@Bean
	public OAuth2AuthorizedClientService authorizedClientService() {
		return new InMemoryOAuth2AuthorizedClientService(this.clientRegistrationRepository());
	}

	private ClientRegistration googleClientRegistration() {
		return CommonOAuth2Provider.GOOGLE.getBuilder("google")
			.clientId("google-client-id")
			.clientSecret("google-client-secret")
			.build();
	}
}
```

#### 5.7.9. OAuth2AuthorizedClient / OAuth2AuthorizedClientService

`OAuth2AuthorizedClient` is a representation of an Authorized Client. A client is considered to be authorized when the end-user (Resource Owner) has granted authorization to the client to access its protected resources.

`OAuth2AuthorizedClient` serves the purpose of associating an `OAuth2AccessToken` to a `ClientRegistration`(client) and resource owner, who is the `Principal` end-user that granted the authorization.

The primary role of the `OAuth2AuthorizedClientService` is to manage `OAuth2AuthorizedClient` instances. From a developer perspective, it provides the capability to lookup an `OAuth2AccessToken` associated with a client so that it may be used to initiate a request to a resource server.

|      | Spring Boot 2.0 Auto-configuration registers an `OAuth2AuthorizedClientService` `@Bean` in the `ApplicationContext`. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

The developer may also register an `OAuth2AuthorizedClientService` `@Bean` in the `ApplicationContext`(overriding Spring Boot 2.0 Auto-configuration) in order to have the ability to lookup an `OAuth2AccessToken` associated with a specific `ClientRegistration` (client).

The following listing shows an example:

```java
@Controller
public class MainController {

	@Autowired
	private OAuth2AuthorizedClientService authorizedClientService;

	@RequestMapping("/userinfo")
	public String userinfo(OAuth2AuthenticationToken authentication) {
		// authentication.getAuthorizedClientRegistrationId() returns the
		// registrationId of the Client that was authorized during the Login flow
		OAuth2AuthorizedClient authorizedClient =
			this.authorizedClientService.loadAuthorizedClient(
				authentication.getAuthorizedClientRegistrationId(),
				authentication.getName());

		OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

		...

		return "userinfo";
	}
}
```

#### 5.7.10. Additional Resources

The following additional resources describe advanced configuration options:

- [OAuth 2.0 Login Page](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#oauth2login-advanced-login-page)
- Authorization Endpoint:
  - [AuthorizationRequestRepository](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#oauth2login-advanced-authorization-request-repository)
- [Redirection Endpoint](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#oauth2login-advanced-redirection-endpoint)
- Token Endpoint:
  - [OAuth2AccessTokenResponseClient](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#oauth2login-advanced-token-client)
- UserInfo Endpoint:
  - [Mapping User Authorities](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#oauth2login-advanced-map-authorities)
  - [Configuring a Custom OAuth2User](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#oauth2login-advanced-custom-user)
  - [OAuth 2.0 UserService](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#oauth2login-advanced-oauth2-user-service)
  - [OpenID Connect 1.0 UserService](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#oauth2login-advanced-oidc-user-service)

### 5.8. Authentication

Thus far we have only taken a look at the most basic authentication configuration. Let’s take a look at a few slightly more advanced options for configuring authentication.

#### 5.8.1. In-Memory Authentication

We have already seen an example of configuring in-memory authentication for a single user. Below is an example to configure multiple users:

```java
@Bean
public UserDetailsService userDetailsService() throws Exception {
	// ensure the passwords are encoded properly
	UserBuilder users = User.withDefaultPasswordEncoder();
	InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
	manager.createUser(users.username("user").password("password").roles("USER").build());
	manager.createUser(users.username("admin").password("password").roles("USER","ADMIN").build());
	return manager;
}
```

#### 5.8.2. JDBC Authentication

You can find the updates to support JDBC based authentication. The example below assumes that you have already defined a `DataSource` within your application. The [jdbc-javaconfig](https://github.com/spring-projects/spring-security/tree/master/samples/javaconfig/jdbc) sample provides a complete example of using JDBC based authentication.

```java
@Autowired
private DataSource dataSource;

@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
	// ensure the passwords are encoded properly
	UserBuilder users = User.withDefaultPasswordEncoder();
	auth
		.jdbcAuthentication()
			.dataSource(dataSource)
			.withDefaultSchema()
			.withUser(users.username("user").password("password").roles("USER"))
			.withUser(users.username("admin").password("password").roles("USER","ADMIN"));
}
```

#### 5.8.3. LDAP Authentication

You can find the updates to support LDAP based authentication. The [ldap-javaconfig](https://github.com/spring-projects/spring-security/tree/master/samples/javaconfig/ldap) sample provides a complete example of using LDAP based authentication.

```java
@Autowired
private DataSource dataSource;

@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
	auth
		.ldapAuthentication()
			.userDnPatterns("uid={0},ou=people")
			.groupSearchBase("ou=groups");
}
```

The example above uses the following LDIF and an embedded Apache DS LDAP instance.

users.ldif

```
dn: ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: groups

dn: ou=people,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: people

dn: uid=admin,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Rod Johnson
sn: Johnson
uid: admin
userPassword: password

dn: uid=user,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Dianne Emu
sn: Emu
uid: user
userPassword: password

dn: cn=user,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: user
uniqueMember: uid=admin,ou=people,dc=springframework,dc=org
uniqueMember: uid=user,ou=people,dc=springframework,dc=org

dn: cn=admin,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: admin
uniqueMember: uid=admin,ou=people,dc=springframework,dc=org
```

#### 5.8.4. AuthenticationProvider

You can define custom authentication by exposing a custom `AuthenticationProvider` as a bean. For example, the following will customize authentication assuming that `SpringAuthenticationProvider` implements `AuthenticationProvider`:

|      | This is only used if the `AuthenticationManagerBuilder` has not been populated |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

```java
@Bean
public SpringAuthenticationProvider springAuthenticationProvider() {
	return new SpringAuthenticationProvider();
}
```

#### 5.8.5. UserDetailsService

You can define custom authentication by exposing a custom `UserDetailsService` as a bean. For example, the following will customize authentication assuming that `SpringDataUserDetailsService` implements `UserDetailsService`:

|      | This is only used if the `AuthenticationManagerBuilder` has not been populated and no `AuthenticationProviderBean` is defined. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

```java
@Bean
public SpringDataUserDetailsService springDataUserDetailsService() {
	return new SpringDataUserDetailsService();
}
```

You can also customize how passwords are encoded by exposing a `PasswordEncoder` as a bean. For example, if you use bcrypt you can add a bean definition as shown below:

```java
@Bean
public BCryptPasswordEncoder passwordEncoder() {
	return new BCryptPasswordEncoder();
}
```

### 5.9. Multiple HttpSecurity（多个HttpSecurity）

We can configure multiple HttpSecurity instances just as we can have multiple `<http>` blocks. The key is to extend the `WebSecurityConfigurationAdapter` multiple times. For example, the following is an example of having a different configuration for URL’s that start with `/api/`.

> 我们可以配置多个HttpSecurity实例，就像我们可以有多个<http>块一样。关键是多次扩展WebSecurityConfigurationAdapter。例如，以下是具有以/api/开头的URL的不同配置的示例

![1565345172593](E:\MyCode\SpringSecurity\my-repositories\spring-security-reference-learning\5.0.12.RELEASE\5. Java Configuration.assets\1565345172593.png)

![1565345189375](E:\MyCode\SpringSecurity\my-repositories\spring-security-reference-learning\5.0.12.RELEASE\5. Java Configuration.assets\1565345189375.png)

|      | Configure Authentication as normal                           |
| ---- | ------------------------------------------------------------ |
|      | Create an instance of `WebSecurityConfigurerAdapter` that contains `@Order` to specify which `WebSecurityConfigurerAdapter` should be considered first.   排序靠前 |
|      | ==The `http.antMatcher` states that this `HttpSecurity` will only be applicable to URLs that start with `/api/`==        （http.antMatcher声明此HttpSecurity仅适用于以/ api /开头的URL） |
|      | Create another instance of `WebSecurityConfigurerAdapter`. If the URL does not start with `/api/` this configuration will be used. This configuration is considered after `ApiWebSecurityConfigurationAdapter` since it has an `@Order`value after `1` (no `@Order` defaults to last). |

> 

### 5.10. Method Security

From version 2.0 onwards Spring Security has improved support substantially for adding security to your service layer methods. It provides support for JSR-250 annotation security as well as the framework’s original `@Secured` annotation. From 3.0 you can also make use of new [expression-based annotations](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#el-access). You can apply security to a single bean, using the `intercept-methods` element to decorate the bean declaration, or you can secure multiple beans across the entire service layer using the AspectJ style pointcuts.

#### 5.10.1. EnableGlobalMethodSecurity

We can enable annotation-based security using the `@EnableGlobalMethodSecurity` annotation on any `@Configuration` instance. For example, the following would enable Spring Security’s `@Secured` annotation.

```java
@EnableGlobalMethodSecurity(securedEnabled = true)
public class MethodSecurityConfig {
// ...
}
```

Adding an annotation to a method (on a class or interface) would then limit the access to that method accordingly. Spring Security’s native annotation support defines a set of attributes for the method. These will be passed to the AccessDecisionManager for it to make the actual decision:

```java
public interface BankService {

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account readAccount(Long id);

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account[] findAccounts();

@Secured("ROLE_TELLER")
public Account post(Account account, double amount);
}
```

Support for JSR-250 annotations can be enabled using

```java
@EnableGlobalMethodSecurity(jsr250Enabled = true)
public class MethodSecurityConfig {
// ...
}
```

These are standards-based and allow simple role-based constraints to be applied but do not have the power Spring Security’s native annotations. To use the new expression-based syntax, you would use

```java
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig {
// ...
}
```

and the equivalent Java code would be

```java
public interface BankService {

@PreAuthorize("isAnonymous()")
public Account readAccount(Long id);

@PreAuthorize("isAnonymous()")
public Account[] findAccounts();

@PreAuthorize("hasAuthority('ROLE_TELLER')")
public Account post(Account account, double amount);
}
```

#### 5.10.2. GlobalMethodSecurityConfiguration

Sometimes you may need to perform operations that are more complicated than are possible with the `@EnableGlobalMethodSecurity` annotation allow. For these instances, you can extend the `GlobalMethodSecurityConfiguration` ensuring that the `@EnableGlobalMethodSecurity` annotation is present on your subclass. For example, if you wanted to provide a custom `MethodSecurityExpressionHandler`, you could use the following configuration:

```java
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
	@Override
	protected MethodSecurityExpressionHandler createExpressionHandler() {
		// ... create and return custom MethodSecurityExpressionHandler ...
		return expressionHandler;
	}
}
```

For additional information about methods that can be overridden, refer to the `GlobalMethodSecurityConfiguration`Javadoc.

#### 5.10.3. EnableReactiveMethodSecurity

Spring Security supports method security using [Reactor’s Context](https://projectreactor.io/docs/core/release/reference/#context) which is setup using `ReactiveSecurityContextHolder`. For example, this demonstrates how to retrieve the currently logged in user’s message.

|      | For this to work the return type of the method must be a `org.reactivestreams.Publisher` (i.e. `Mono`/`Flux`). This is necessary to integrate with Reactor’s `Context`. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

```java
Authentication authentication = new TestingAuthenticationToken("user", "password", "ROLE_USER");

Mono<String> messageByUsername = ReactiveSecurityContextHolder.getContext()
	.map(SecurityContext::getAuthentication)
	.map(Authentication::getName)
	.flatMap(this::findMessageByUsername)
	// In a WebFlux application the `subscriberContext` is automatically setup using `ReactorContextWebFilter`
	.subscriberContext(ReactiveSecurityContextHolder.withAuthentication(authentication));

StepVerifier.create(messageByUsername)
	.expectNext("Hi user")
	.verifyComplete();
```

with `this::findMessageByUsername` defined as:

```java
Mono<String> findMessageByUsername(String username) {
	return Mono.just("Hi " + username);
}
```

Below is a minimal method security configuration when using method security in reactive applications.

```java
@EnableReactiveMethodSecurity
public class SecurityConfig {
	@Bean
	public MapReactiveUserDetailsService userDetailsService() {
		User.UserBuilder userBuilder = User.withDefaultPasswordEncoder();
		UserDetails rob = userBuilder.username("rob").password("rob").roles("USER").build();
		UserDetails admin = userBuilder.username("admin").password("admin").roles("USER","ADMIN").build();
		return new MapReactiveUserDetailsService(rob, admin);
	}
}
```

Consider the following class:

```java
@Component
public class HelloWorldMessageService {
	@PreAuthorize("hasRole('ADMIN')")
	public Mono<String> findMessage() {
		return Mono.just("Hello World!");
	}
}
```

Combined with our configuration above, `@PreAuthorize("hasRole('ADMIN')")` will ensure that `findByMessage` is only invoked by a user with the role `ADMIN`. It is important to note that any of the expressions in standard method security work for `@EnableReactiveMethodSecurity`. However, at this time we only support return type of `Boolean` or `boolean` of the expression. This means that the expression must not block.

When integrating with [WebFlux Security](https://docs.spring.io/spring-security/site/docs/5.0.12.RELEASE/reference/html5/#jc-webflux), the Reactor Context is automatically established by Spring Security according to the authenticated user.

```java
@EnableWebFluxSecurity
@EnableReactiveMethodSecurity
public class SecurityConfig {

	@Bean
	SecurityWebFilterChain springWebFilterChain(ServerHttpSecurity http) throws Exception {
		return http
			// Demonstrate that method security works
			// Best practice to use both for defense in depth
			.authorizeExchange()
				.anyExchange().permitAll()
				.and()
			.httpBasic().and()
			.build();
	}

	@Bean
	MapReactiveUserDetailsService userDetailsService() {
		User.UserBuilder userBuilder = User.withDefaultPasswordEncoder();
		UserDetails rob = userBuilder.username("rob").password("rob").roles("USER").build();
		UserDetails admin = userBuilder.username("admin").password("admin").roles("USER","ADMIN").build();
		return new MapReactiveUserDetailsService(rob, admin);
	}
}
```

You can find a complete sample in [hellowebflux-method](https://github.com/spring-projects/spring-security/tree/5.0.12.RELEASE/samples/javaconfig/hellowebflux-method)

### 5.11. Post Processing Configured Objects

Spring Security’s Java Configuration does not expose every property of every object that it configures. This simplifies the configuration for a majority of users. Afterall, if every property was exposed, users could use standard bean configuration.

While there are good reasons to not directly expose every property, users may still need more advanced configuration options. To address this Spring Security introduces the concept of an `ObjectPostProcessor` which can be used to modify or replace many of the Object instances created by the Java Configuration. For example, if you wanted to configure the `filterSecurityPublishAuthorizationSuccess` property on `FilterSecurityInterceptor` you could use the following:

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
			.anyRequest().authenticated()
			.withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {
				public <O extends FilterSecurityInterceptor> O postProcess(
						O fsi) {
					fsi.setPublishAuthorizationSuccess(true);
					return fsi;
				}
			});
}
```

### 5.12. Custom DSLs

You can provide your own custom DSLs in Spring Security. For example, you might have something that looks like this:

```java
public class MyCustomDsl extends AbstractHttpConfigurer<MyCustomDsl, HttpSecurity> {
	private boolean flag;

	@Override
	public void init(H http) throws Exception {
		// any method that adds another configurer
		// must be done in the init method
		http.csrf().disable();
	}

	@Override
	public void configure(H http) throws Exception {
		ApplicationContext context = http.getSharedObject(ApplicationContext.class);

		// here we lookup from the ApplicationContext. You can also just create a new instance.
		MyFilter myFilter = context.getBean(MyFilter.class);
		myFilter.setFlag(flag);
		http.addFilterBefore(myFilter, UsernamePasswordAuthenticationFilter.class);
	}

	public MyCustomDsl flag(boolean value) {
		this.flag = value;
		return this;
	}

	public static MyCustomDsl customDsl() {
		return new MyCustomDsl();
	}
}
```

|      | This is actually how methods like `HttpSecurity.authorizeRequests()` are implemented. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

The custom DSL can then be used like this:

```java
@EnableWebSecurity
public class Config extends WebSecurityConfigurerAdapter {
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.apply(customDsl())
				.flag(true)
				.and()
			...;
	}
}
```

The code is invoked in the following order:

- Code in `Config`s configure method is invoked
- Code in `MyCustomDsl`s init method is invoked
- Code in `MyCustomDsl`s configure method is invoked

If you want, you can have `WebSecurityConfiguerAdapter` add `MyCustomDsl` by default by using `SpringFactories`. For example, you would create a resource on the classpath named `META-INF/spring.factories` with the following contents:

META-INF/spring.factories

```
org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer = sample.MyCustomDsl
```

Users wishing to disable the default can do so explicitly.

```java
@EnableWebSecurity
public class Config extends WebSecurityConfigurerAdapter {
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.apply(customDsl()).disable()
			...;
	}
}
```

## 





